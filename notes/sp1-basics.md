## Why zkVMs Matter

zkVMs enable:

- Verifiable computation without re-execution  
- Reduced trust assumptions between parties  
- Complex logic to be proven on-chain or off-chain  
- New designs for rollups, ZK applications, and verification systems  

They represent a shift from **“trust the executor”** to **“verify the computation.”**

---

## Current Understanding

At this stage, learning is focused on **concepts and system design**, not implementation details.

So far:

- Programs are executed inside the zkVM  
- A prover generates a proof of correct execution  
- A verifier checks this proof efficiently  

This repository documents understanding as it evolves.

---

## Open Questions

- What are the practical resource requirements for local proving?  
- What is the best entry point for generating a first SP1 proof?  
- What are the tradeoffs between zkVM-based ZK systems and circuit-based ZK systems?  
- How does SP1 handle performance bottlenecks at scale?  

These questions will guide further exploration.

---

## Status

Early-stage learning notes.  
Content will be updated as understanding improves.
